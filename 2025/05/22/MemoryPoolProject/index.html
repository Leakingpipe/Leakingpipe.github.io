<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NEW PROJECT! Memory Pool!! | Chengcen Fu's Blog</title><meta name="author" content="Chengcen Fu"><meta name="copyright" content="Chengcen Fu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NEW PROJECT! Memory Pool!! Starting date: 2025-05-13Another project begins! Prerequisites:To understand memory pool better, let’s review STL::allocator first STL::allocatorIt is used to manage memory">
<meta property="og:type" content="article">
<meta property="og:title" content="NEW PROJECT! Memory Pool!!">
<meta property="og:url" content="http://example.com/2025/05/22/MemoryPoolProject/index.html">
<meta property="og:site_name" content="Chengcen Fu&#39;s Blog">
<meta property="og:description" content="NEW PROJECT! Memory Pool!! Starting date: 2025-05-13Another project begins! Prerequisites:To understand memory pool better, let’s review STL::allocator first STL::allocatorIt is used to manage memory">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/favicon.png">
<meta property="article:published_time" content="2025-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-22T09:31:18.223Z">
<meta property="article:author" content="Chengcen Fu">
<meta property="article:tag" content="MemoryPoolProject">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/05/22/MemoryPoolProject/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NEW PROJECT! Memory Pool!!',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-22 05:31:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 22 || hour >= 10
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/aboutme/"><i class="fa-fw fas fa-heart"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-video"></i><span> Portfolio</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Chengcen Fu's Blog"><span class="site-name">Chengcen Fu's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/aboutme/"><i class="fa-fw fas fa-heart"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-video"></i><span> Portfolio</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NEW PROJECT! Memory Pool!!</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-22T16:00:00.000Z" title="Created 2025-05-22 12:00:00">2025-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-22T09:31:18.223Z" title="Updated 2025-05-22 05:31:18">2025-05-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NEW PROJECT! Memory Pool!!"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NEW-PROJECT-Memory-Pool"><a href="#NEW-PROJECT-Memory-Pool" class="headerlink" title="NEW PROJECT! Memory Pool!!"></a>NEW PROJECT! Memory Pool!!</h1><hr>
<p><strong>Starting date: 2025-05-13</strong><br>Another project begins!</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites:"></a>Prerequisites:</h2><p>To understand memory pool better, let’s review <code>STL::allocator</code> first</p>
<h3 id="STL-allocator"><a href="#STL-allocator" class="headerlink" title="STL::allocator"></a>STL::allocator</h3><p>It is used to manage memory allocation in C++ standard library.<br>In order to understand how an allocator is defined and how does it work, I wrote one myself:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="type">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">MyAllocator</span>() <span class="keyword">noexcept</span> &#123;&#125; </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="built_in">MyAllocator</span>(<span class="type">const</span> MyAllocator&lt;U&gt;&amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate memory</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Allocate]&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;element\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(n * <span class="built_in">sizeof</span>(T)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release memory</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p, std::<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Deallocate] &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; element(s)\n&quot;</span>;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebinding forming new type</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> other = MyAllocator&lt;U&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyAllocator&lt;T&gt;&amp;, <span class="type">const</span> MyAllocator&lt;U&gt;&amp;) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> MyAllocator&lt;T&gt;&amp;, <span class="type">const</span> MyAllocator&lt;U&gt;&amp;) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>This allocator fulfills the standard allocator requirements. It declares different type aliases and provides type conversion and rebind template to support rebinding to different element types. </p>
<p><img src="/img/MemPool_allocator.png"><br>It works! :D</p>
<hr>
<h3 id="SGI-STL-allocator"><a href="#SGI-STL-allocator" class="headerlink" title="SGI STL allocator"></a>SGI STL allocator</h3><p>Before we move on to creating the project by ourselves, let’s look at more examples of allocators.</p>
<p>STL allocator are usually devided into two levels. If the chunk is bigger that 128 bytes, then first-level allocator will be called.</p>
<h4 id="first-level-allocator"><a href="#first-level-allocator" class="headerlink" title="first-level allocator"></a>first-level allocator</h4><p>The process usually gose like this: It first tries to allocate memory directly. If the allocation succeeds, it immediately returns the memory block. However, if the allocation fails, it triggers the out-of-memory handling mechanism. The allocator checks whether a custom handler has been registered to release memory in low-memory situations.<br>If no handler is set, the program will throw an exception and terminate. But if a handler is present, it will be executed in an attempt to release memory and reattempt the allocation. This process repeats until the allocation eventually succeeds.<br>Nevertheless, there is a potential issue: if the handler is not well-designed — in other words, it fails to actually release any usable memory and simply returns without taking meaningful action — it may lead to an infinite loop.<br>To avoid this risk, the SGI STL by default does not set this handler (i.e., it is null). As a result, if memory allocation fails, the program will immediately terminate.This approach ensures that the program fails fast and avoids unpredictable behavior caused by faulty recovery logic.<br>If allocation finally succeeds, the memory block is returned.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*MALLOCALLOC)</span><span class="params">()</span></span>;           <span class="comment">//rename void (*)() as MALLOCALLOC</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_MallocAllocTemplate</span> <span class="comment">//offers Allocate /De allocate </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">static</span> <span class="type">void</span>* _OomMalloc(<span class="type">size_t</span>);       <span class="comment">//called when malloc failed</span></span><br><span class="line">       <span class="type">static</span> MALLOCALLOC _MallocAllocOomHandler;         <span class="comment">// store OOM handler</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="type">static</span> <span class="type">void</span>* _Allocate(<span class="type">size_t</span> n)                        <span class="comment">// allocate n bytes of memory</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="type">void</span> *result=<span class="number">0</span>;</span><br><span class="line">              result = <span class="built_in">malloc</span>(n);                 <span class="comment">//call malloc to allocate memory</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == result)                    <span class="comment">// call OOM_malloc if malloc failed</span></span><br><span class="line">                     _OomMalloc(n);</span><br><span class="line">              <span class="keyword">return</span> result;                      <span class="comment">// return the address of the allocated memory</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">static</span> <span class="type">void</span> _DeAllocate(<span class="type">void</span> *p)                <span class="comment">// free the memory</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">free</span>(p);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">static</span> MALLOCALLOC _SetMallocHandler(MALLOCALLOC f)    <span class="comment">// to set OOM handler</span></span><br><span class="line">       &#123;</span><br><span class="line">              MALLOCALLOC old = _MallocAllocOomHandler;</span><br><span class="line">              _MallocAllocOomHandler = f;              <span class="comment">// pass function f, as a emergency function if memory allocation failed</span></span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span></span><br><span class="line"><span class="function"><span class="title">void</span><span class="params">(* _MallocAllocTemplate&lt;inst&gt;::_MallocAllocOomHandler)</span><span class="params">()</span></span>=<span class="number">0</span>;    <span class="comment">// set default as not cope with out of memory mechanism</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* _MallocAllocTemplate&lt;inst&gt;::_OomMalloc(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">       MALLOCALLOC _MyMallocHandler;     <span class="comment">// define a function pointer</span></span><br><span class="line">       <span class="type">void</span> *result;               </span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">              _MyMallocHandler = _MallocAllocOomHandler;</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == _MyMallocHandler)                  <span class="comment">// handler is not set -&gt; failed</span></span><br><span class="line">                     <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();                  <span class="comment">// throw an exception</span></span><br><span class="line">              (*_MyMallocHandler)();                 <span class="comment">// call handler to release memory</span></span><br><span class="line">              <span class="keyword">if</span> (result = <span class="built_in">malloc</span>(n))                <span class="comment">// try allocate again</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;                              <span class="comment">// return if succeed</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> _MallocAllocTemplate&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>

<h4 id="second-level-allocator"><a href="#second-level-allocator" class="headerlink" title="second-level allocator"></a>second-level allocator</h4><p>The second-level allocator handles small memory allocations (≤128 bytes) using a memory pool and multiple free lists to improve speed and reduce fragmentation. When memory is requested, it first checks the appropriate free list for a block of the required size. If available, it returns the block directly. If not, it requests a large chunk of memory from the first-level allocator (which uses malloc), splits it into small blocks, stores them in the free list, and returns one to the user. This layered design combines efficient small object reuse with large block allocation from the system.</p>
<p>The second-level allocator places the large memory blocks allocated from first-level allocator into a memory pool (pointed to by _start_free and _end_free), and then slices out small blocks from this pool as needed and attaches them to the linked lists of multiple free_list[]. </p>
<h5 id="Logic-Flow-of-the-second-level-allocator"><a href="#Logic-Flow-of-the-second-level-allocator" class="headerlink" title="Logic Flow of the second-level allocator:"></a>Logic Flow of the second-level allocator:</h5><p><strong>Size check:</strong> When memory is requested, the allocator first checks if the requested size exceeds the maximum threshold (typically 128 bytes). If the size is greater than 128 bytes, the allocator delegates the request to the first-level allocator (<code>malloc_alloc</code>), which uses <code>malloc</code> directly.<br><strong>Free list lookup:</strong> The requested size is rounded up to the nearest multiple of 8 bytes to maintain alignment. Then, the allocator checks the corresponding free list for a block of that size. If the free list has available blocks, the allocator pops one from the list and returns it. If the free list is empty, the allocator calls <code>_Refill()</code>.<br><strong>Refill mechanism:</strong> <code>_Refill(n)</code> tries to allocate multiple blocks of size <code>n</code> at once (typically 20) to improve future allocation efficiency. It calls <code>_ChunkAlloc(size, nobjs)</code> to cut a large chunk of memory into small blocks. One block is returned to the user; the remaining are linked into the appropriate free list.<br>_<em>Chunk allocation(<code><em>ChunkAlloc</code>):</em></em> This function attempts to cut memory from the internal memory pool defined by <code>_start_free</code> and <code>_end_free</code>. If enough memory exists, it returns a batch of blocks. If not enough memory remains, it attempts to allocate a new large chunk from the first-level allocator and updates the internal memory pool. If this also fails, it may search other free lists for recyclable blocks or fall back to the first-level allocator’s OOM handler.<br><strong>Deallocation:</strong> When memory is returned, it is pushed back to the appropriate free list, using the block’s starting address as a next pointer in the linked list structure.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; _ALIGN = <span class="number">8</span> &#125;;              <span class="comment">// Perform memory operations in multiples of the base value 8</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _MAXBYTES = <span class="number">128</span> &#125;;        <span class="comment">// the largest chunk in the free list is 128 byte</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _NFREELISTS = <span class="number">16</span> &#125;;       <span class="comment">// the length of the free list, == _MAXBYTES/_ALIGN</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_DefaultAllocTemplate</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">union</span> <span class="title class_">_Obj</span>                      <span class="comment">// free list node type</span></span><br><span class="line">       &#123;</span><br><span class="line">              _Obj* _freeListLink;         <span class="comment">// this pointer points to free list node</span></span><br><span class="line">              <span class="type">char</span> _clientData[<span class="number">1</span>];          <span class="comment">//this client sees</span></span><br><span class="line">       &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* _startFree;             <span class="comment">// head pointer to the memory pool</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* _endFree;               <span class="comment">// tail pointer</span></span><br><span class="line">       <span class="type">static</span> <span class="type">size_t</span> _heapSize;              <span class="comment">// record the size of memory the pool has applied from the system</span></span><br><span class="line">       <span class="type">static</span> _Obj* <span class="keyword">volatile</span> _freeList[_NFREELISTS];    <span class="comment">//free list</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">static</span> <span class="type">size_t</span> _GetFreeListIndex(<span class="type">size_t</span> bytes)   <span class="comment">// get the position of the byte in the free list and transform the size into its index</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">return</span> (bytes +(<span class="type">size_t</span>) _ALIGN - <span class="number">1</span>) / (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>;     </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">static</span> <span class="type">size_t</span> _GetRoundUp(<span class="type">size_t</span> bytes)        <span class="comment">// Round up any byte size to a multiple of 8 for alignment</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">return</span> (bytes + (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>)&amp;(~(_ALIGN<span class="number">-1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="type">static</span> <span class="type">void</span>* _Refill(<span class="type">size_t</span> n);          <span class="comment">// apply about 20 chuncks with each size of n bytes, return the first one</span></span><br><span class="line">       <span class="type">static</span> <span class="type">char</span>* _chunkAlloc(<span class="type">size_t</span> size,<span class="type">int</span>&amp; nobjs);    <span class="comment">//Allocate memory from the memory pool for nobjs objects, each of size size</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>;      <span class="comment">//External allocation entry point, n larger than 0</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeAllocate</span><span class="params">(<span class="type">void</span> *p,<span class="type">size_t</span> n)</span></span>;        <span class="comment">// n != 0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads,<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* _DefaultAllocTemplate&lt;threads,inst&gt;::_startFree = <span class="number">0</span>;        <span class="comment">//head pointer of the pool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* _DefaultAllocTemplate&lt;threads, inst&gt;::_endFree=<span class="number">0</span>;           <span class="comment">// end pointer of the pool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">size_t</span> _DefaultAllocTemplate&lt;threads, inst&gt;::_heapSize = <span class="number">0</span>;              <span class="comment">// record how much memory that the pool has applied from the system</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> _DefaultAllocTemplate&lt;threads, inst&gt;::_Obj* <span class="keyword">volatile</span>      <span class="comment">//&#x27;typename&#x27; indicates that &#x27;_Obj*&#x27; is a type dependent on the template parameters.</span></span><br><span class="line">_DefaultAllocTemplate&lt;threads, inst&gt;::_freeList[_NFREELISTS] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//free list</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* _DefaultAllocTemplate&lt;threads, inst&gt;::<span class="built_in">Allocate</span>(<span class="type">size_t</span> n)    <span class="comment">// allocate memory</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">void</span> *ret;</span><br><span class="line">       <span class="comment">//First check whether the requested memory size is greater than 128 bytes</span></span><br><span class="line">       <span class="keyword">if</span> (n&gt;_MAXBYTES)      <span class="comment">// If greater than _MAXBYTES, treat it as a large memory block and use the first-level allocator directly</span></span><br><span class="line">       &#123;</span><br><span class="line">              ret = malloc_alloc::_Allocate(n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>       <span class="comment">// Otherwise, look for available space in the free list</span></span><br><span class="line">       &#123;</span><br><span class="line">              _Obj* <span class="keyword">volatile</span> *myFreeList = _freeList+_GetFreeListIndex(n);  <span class="comment">// Let myFreeList point to the free list corresponding to n rounded up to the nearest multiple of 8</span></span><br><span class="line">              _Obj* result = *myFreeList;</span><br><span class="line">              <span class="keyword">if</span> (result == <span class="number">0</span>)  <span class="comment">// If no memory is linked at this node, request memory from the memory pool</span></span><br><span class="line">              &#123;</span><br><span class="line">                     ret = _Refill(_GetRoundUp(n));      <span class="comment">//  Request memory from the memory pool</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span>            <span class="comment">//Memory has been found in the free list</span></span><br><span class="line">              &#123;</span><br><span class="line">                     *myFreeList= result-&gt;_freeListLink;      <span class="comment">//Put the address of the second memory block back into the free list</span></span><br><span class="line">                     ret = result;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> _DefaultAllocTemplate&lt;threads, inst&gt;::<span class="built_in">DeAllocate</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">//check the size of the memory block</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; _MAXBYTES)  <span class="comment">//If n exceeds the maximum block size managed by the free list, call the first-level deallocator directly</span></span><br><span class="line">       &#123;</span><br><span class="line">              malloc_alloc::_DeAllocate(p);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>        <span class="comment">//Recycle the memory block back into the free list</span></span><br><span class="line">       &#123;</span><br><span class="line">              _Obj* q = (_Obj*)p;</span><br><span class="line">              _Obj* <span class="keyword">volatile</span> *myFreeList = _freeList + _GetFreeListIndex(n);</span><br><span class="line">              q-&gt;_freeListLink = *myFreeList;</span><br><span class="line">              *myFreeList = q;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads,<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* _DefaultAllocTemplate&lt;threads, inst&gt;::_Refill(<span class="type">size_t</span> n)     <span class="comment">// &#x27;n&#x27; indicates the number of bytes to allocate</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> nobjs = <span class="number">20</span>;           <span class="comment">// When requesting memory from the pool, allocate 20 at once</span></span><br><span class="line">       <span class="type">char</span>* chunk = _chunkAlloc(n,nobjs);    <span class="comment">// Since the free list is currently empty, request memory from the pool and add the remaining objects to the free list</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1</span> == nobjs)          <span class="comment">// Only one object was allocated</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">return</span> chunk;</span><br><span class="line">       &#125;</span><br><span class="line">       _Obj* ret = (_Obj*)chunk;                  <span class="comment">// Return the first allocated object as the return value</span></span><br><span class="line">       _Obj* <span class="keyword">volatile</span> *myFreeList = _freeList+ _GetFreeListIndex(n);</span><br><span class="line">       *myFreeList =(_Obj*)(chunk+n);             <span class="comment">// Add the second object&#x27;s address to the free list</span></span><br><span class="line">       _Obj* cur= *myFreeList;</span><br><span class="line">       _Obj* next=<span class="number">0</span>;</span><br><span class="line">       cur-&gt;_freeListLink = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nobjs; ++i)             <span class="comment">// Link the remaining blocks into the free list</span></span><br><span class="line">       &#123;</span><br><span class="line">              next= (_Obj*)(chunk + n*i);</span><br><span class="line">              cur-&gt;_freeListLink = next;</span><br><span class="line">              cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       cur-&gt;_freeListLink = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* _DefaultAllocTemplate&lt;threads, inst&gt;::_chunkAlloc(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)  <span class="comment">//Request memory from the system</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">char</span>* result = <span class="number">0</span>;</span><br><span class="line">       <span class="type">size_t</span> totalBytes = size*nobjs;        <span class="comment">//Total number of bytes requested</span></span><br><span class="line">       <span class="type">size_t</span> leftBytes = _endFree - _startFree;      <span class="comment">//Remaining bytes in the memory pool</span></span><br><span class="line">       <span class="keyword">if</span> (leftBytes&gt;=totalBytes)     <span class="comment">//If the remaining pool memory is enough, allocate directly</span></span><br><span class="line">       &#123;</span><br><span class="line">              result = _startFree;</span><br><span class="line">              _startFree += totalBytes;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (leftBytes&gt;size)         <span class="comment">//If only enough for fewer objects</span></span><br><span class="line">       &#123;</span><br><span class="line">              nobjs=(<span class="type">int</span>)(leftBytes/size);    <span class="comment">// Adjust the number of objects accordingly</span></span><br><span class="line">              result = _startFree;</span><br><span class="line">              _startFree +=(nobjs*size);</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>            <span class="comment">//Not even enough for one object</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="type">size_t</span> NewBytes = <span class="number">2</span> * totalBytes+_GetRoundUp(_heapSize&gt;&gt;<span class="number">4</span>);       <span class="comment">//Calculate new memory pool size</span></span><br><span class="line">              <span class="keyword">if</span> (leftBytes &gt;<span class="number">0</span>)  <span class="comment">//Recycle remaining memory into the free list</span></span><br><span class="line">              &#123;</span><br><span class="line">              &#123;</span><br><span class="line">                     _Obj* <span class="keyword">volatile</span> *myFreeList = _freeList + _GetFreeListIndex(leftBytes);</span><br><span class="line">                     ((_Obj*)_startFree)-&gt;_freeListLink = *myFreeList;</span><br><span class="line">                     *myFreeList = (_Obj*)_startFree;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//Try to allocate new memory from the system</span></span><br><span class="line">              _startFree = (<span class="type">char</span>*)<span class="built_in">malloc</span>(NewBytes);</span><br><span class="line">              <span class="keyword">if</span> (<span class="number">0</span> == _startFree)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="comment">// Search the free list for a larger block to use as the new pool if allocate failed</span></span><br><span class="line">                     <span class="keyword">for</span> (<span class="type">size_t</span> i = size; i &lt;(<span class="type">size_t</span>)_MAXBYTES;i+=(<span class="type">size_t</span>)_ALIGN)</span><br><span class="line">                     &#123;</span><br><span class="line">                           _Obj* <span class="keyword">volatile</span> *myFreeList = _freeList + _GetFreeListIndex(i);</span><br><span class="line">                           _Obj* p =*myFreeList;</span><br><span class="line">                           <span class="keyword">if</span> (<span class="literal">NULL</span> != p)       <span class="comment">//Found a block in the free list</span></span><br><span class="line">                           &#123;</span><br><span class="line">                                  _startFree =(<span class="type">char</span>*)p;                  </span><br><span class="line">                                  <span class="comment">//Remove this block from the free list and assign it to the memory pool</span></span><br><span class="line">                                  *myFreeList = p-&gt;_freeListLink;</span><br><span class="line">                                  _endFree = _startFree + i;</span><br><span class="line">                                  <span class="keyword">return</span> _chunkAlloc(size, nobjs);  <span class="comment">//Retry allocation with updated pool</span></span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// If still no memory found, fall back to the first-level allocator which has its own out-of-memory handling mechanism (may throw)</span></span><br><span class="line">                     _endFree = <span class="literal">NULL</span>;</span><br><span class="line">                     _startFree=(<span class="type">char</span>*)malloc_alloc::_Allocate(NewBytes);</span><br><span class="line">              &#125;      </span><br><span class="line">              <span class="comment">//Allocation succeeded, update heapSize, and _endFree</span></span><br><span class="line">              _heapSize += NewBytes;</span><br><span class="line">              _endFree = _startFree + NewBytes;</span><br><span class="line">              <span class="keyword">return</span> _chunkAlloc(size, nobjs);             <span class="comment">//Retry allocation with updated pool</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> _DefaultAllocTemplate&lt;<span class="number">0</span>,<span class="number">0</span>&gt;  default_alloc;</span><br></pre></td></tr></table></figure>

<p>To put it in a simple way, <code>free_list[i]</code> works like a shelf in a store, <code>_Refill(n)</code> acts as a worker that restocks the shelf, and <code>_chunkAllocate()</code> is the way to acquire new supplies. <code>_startFree</code> and <code>_endFree</code> indicate the remaining space in the inventory (memory pool).</p>
<p>As for <code>_chunkAlloc()</code> </p>
<ul>
<li><p>if there’s enough space:</p>
<ul>
<li>If <code>_endFree - _startFree</code> ≥ <code>nobjs * size</code></li>
<li>Directly return the memory block and update <code>_startFree</code></li>
</ul>
</li>
<li><p>if there’s only part enough remaining space:</p>
<ul>
<li>Can’t get all <code>nobjs</code>, but can get at least one block</li>
<li>Adjust <code>nobjs</code>, return what’s available</li>
</ul>
</li>
<li><p>not enough space：</p>
<ul>
<li>Not even one block fits</li>
<li>Recycle leftover memory to free list</li>
<li>Request more memory from system via <code>malloc()</code></li>
<li>If system fails, try scavenging other free lists</li>
<li>Finally fallback to first-level allocator (may throw)</li>
</ul>
</li>
</ul>
<h3 id="Spinlock"><a href="#Spinlock" class="headerlink" title="Spinlock"></a>Spinlock</h3><p>A spinlock is a lightweight synchronization primitive used in multithreaded programming to protect shared resources from concurrent access.<br>Unlike traditional mutexes, a spinlock does not put the thread to sleep when the lock is already held. Instead, the thread “spins” in a loop, repeatedly checking until the lock becomes available.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// busy wait (spin)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>test_and_set()</code> is an atomic operation that attempts to set the lock to true and returns its previous value. If the lock was already true (held), the thread keeps spinning. Once it reads false, it means the lock is free, and the thread takes it.</p>
<h4 id="When-to-use-spinlocks"><a href="#When-to-use-spinlocks" class="headerlink" title="When to use spinlocks?"></a>When to use spinlocks?</h4><ol>
<li>Short critical sections where holding time is minimal;</li>
<li>High-frequency, low-contention scenarios;</li>
<li>Systems where thread context switching is expensive (e.g., real-time or low-latency systems).</li>
</ol>
<h4 id="Advantages-of-spinlocks"><a href="#Advantages-of-spinlocks" class="headerlink" title="Advantages of spinlocks:"></a>Advantages of spinlocks:</h4><ol>
<li>Fast and low-overhead when the lock is uncontended;</li>
<li>No need for system calls or thread suspension;</li>
<li>Ideal for situations where lock is expected to be released very quickly.</li>
</ol>
<h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h4><ol>
<li>Wastes CPU cycles during spinning (especially under contention);</li>
<li>Not suitable for long blocking operations;</li>
<li>Can cause CPU starvation if not designed carefully.</li>
</ol>
<h4 id="Spinlock-vs-Mutex"><a href="#Spinlock-vs-Mutex" class="headerlink" title="Spinlock vs. Mutex"></a>Spinlock vs. Mutex</h4><table>
<thead>
<tr>
<th align="center">Features</th>
<th align="center">Spinlock</th>
<th align="center">Mutex</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Blocking</td>
<td align="center">No, busy waitiing</td>
<td align="center">Yes, thread sleeps</td>
</tr>
<tr>
<td align="center">CPU usage</td>
<td align="center">High under contention</td>
<td align="center">Lower</td>
</tr>
<tr>
<td align="center">Overhead</td>
<td align="center">Low(no context switch)</td>
<td align="center">High(system-level)</td>
</tr>
<tr>
<td align="center">Use case</td>
<td align="center">Fast, shrot operations</td>
<td align="center">Long or IO-bound operations</td>
</tr>
</tbody></table>
<h2 id="Code-framework-provided-by-instructor"><a href="#Code-framework-provided-by-instructor" class="headerlink" title="Code framework:(provided by instructor)"></a>Code framework:(provided by instructor)</h2><p>This code frame is provided by Carl at <a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/memory-pool">https://github.com/youngyangyang04/memory-pool</a></p>
<h3 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h3><p>The hash bucket maps requested byte sizes to corresponding MemoryPools. Each MemoryPool batches fixed-size 4096-byte Blocks from the system, but only slices them into Slots of a single SlotSize.<br><strong>Allocation process:</strong><br>When <code>newElement</code> is called, it first checks the freeList — if there is an available Slot, it returns one in O(1) time.<br>If the list is empty, a new Slot is carved from curSlot.<br>Once the current Block is cut up, <code>_chunkAlloc</code> is triggered to request a new Block,<br>which is linked via a head pointer stored in each Block, and <code>firstBlock</code> records the chain head.<br><strong>Deallocation process:</strong><br>When <code>deleteElement</code> is called, the returned Slot is turned into a pointer to the previous head and pushed back onto the freeList for future reuse. To maintain page alignment, the end of a Block may contain a padding area.</p>
<h4 id="Optimization-lock-free-datastructure"><a href="#Optimization-lock-free-datastructure" class="headerlink" title="Optimization: lock-free datastructure"></a>Optimization: lock-free datastructure</h4><p>This improvement tries to use a lock-free data structure to manage free slots. </p>
<p>This optimization </p>
<ol>
<li>first introduces atomic operations by replacing regular pointers with <code>std::atomic<Slot*> </code>, and implements lock-free Compare-And-Swap (CAS) to ensure thread safety.</li>
<li>Memory ordering are applied to guarantee consistency and visibility across threads.<br>The free slots are managed using a stack-like structure, ensuring that each push and pop operation only manipulates the top element, enabling fast and contention-free access.</li>
<li>Finally, the mutex protecting free slot operations is removed to reduce lock contention (as these operations are frequent), while the mutex for block allocation is preserved, since it is triggered infrequently and does not significantly impact performance.</li>
</ol>
<h3 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h3><p>In the second version of the memory pool project, a three-tier caching architecture was introduced, similar to the design adopted by mainstream allocators such as tcmalloc and jemalloc.<br>The structure consists of <strong>ThreadCache</strong>, <strong>CentralCache</strong>, and <strong>PageCache</strong>, each responsible for thread-local storage, centralized coordination, and system memory management, respectively.<br>This architecture improves the efficiency of small-object memory allocation in multithreaded environments, while avoiding frequent allocation and deallocation requests to the operating system.</p>
<h4 id="1-ThreadCache"><a href="#1-ThreadCache" class="headerlink" title="1. ThreadCache"></a>1. ThreadCache</h4><p>First, ThreadCache provides each thread with an independent cache for small objects, effectively avoiding inter-thread lock contention. It’s like having a private memory drawer under each thread’s desk — no locking is needed, so allocation becomes much faster.</p>
<p>Internally, it maintains a <code>FreeList[]</code> array, where each slot holds a singly linked list that manages memory blocks of a specific size. When a slot runs out of memory, the thread will batch-fetch new blocks from the <strong>CentralCache</strong>. If there are too many unused blocks, they will be returned in bulk.</p>
<p>The <code>ThreadCache</code> class uses a thread-local singleton instance (<code>thread_local</code>)， so each thread owns its private cache that cannot be accessed by others — just like a personal drawer.<br>It defines four key methods:</p>
<ol>
<li><code>allocate()</code> and <code>deallocate()</code> for allocating and releasing small objects.</li>
<li><code>fetchFromCentralCache()</code> and <code>returnToCentralCache()</code> for bulk acquiring and returning memory blocks. Additionally, it maintains an array <code>freeList_[]</code> to manage free memory of various sizes using linked lists.</li>
</ol>
<h4 id="2-CentralCache"><a href="#2-CentralCache" class="headerlink" title="2. CentralCache"></a>2. CentralCache</h4><p>CentralCache acts as the middle layer between ThreadCache and PageCache.<br>Its main responsibility includes:</p>
<ul>
<li>Managing free lists for different object sizes;</li>
<li>Allocating memory blocks from PageCache in batches;</li>
<li>Providing allocation and recycling services to multiple ThreadCaches;</li>
<li>Supporting thread-safe operations using lock-free atomic pointers and lightweight spinlocks.</li>
</ul>
<p>The <code>centralFreeList_</code> is an array of atomic pointers to manage the free memory blocks,<br>while the <code>locks_</code> array contains atomic flags for protecting each individual free list.</p>
<p>The main implementation includes four steps:</p>
<ol>
<li>Try to acquire the lock (Spinlock):It uses <code>test_and_set(memory_order_acquire)</code> to acquire a lock on the corresponding free list. Just like flipping a “busy” sign before accessing a shared file folder, making sure only one person can open it at a time.</li>
<li>Attempt to load from the central free list: It calls <code>.load(memory_order_relaxed)</code> to check if there’s any memory available. It’s like peeking in to the drawing without worrying if it’s up-to-date, just a quick glance to see if something’s there. </li>
<li>If empty, fetch from PageCache: Calls <code>fetchFromPageCache()</code> to get a large chunk and splits it into small blocks. It’s like when the drawer is empty, you go to the warehouse and bring back a whole box to restock.</li>
<li>Update the free list head and return: Uses <code>.store(memory_order_release)</code> to update the free list with the new head. Just like after restocking, you properly put the new box in place and lable it so others know it’s ready.</li>
</ol>
<p><strong>Design Feature: Batch Allocation</strong><br>In the memory pool design, <code>CentralCache</code> does not request memory from <code>PageCache</code> one page at a time. Instead, it batches the allocation using a constant value (e.g., <code>SPAN_PAGES = 8</code>), meaning it fetches 8 pages in one go.<br>This improves performance by:</p>
<ul>
<li>Reducing the number of calls to <code>PageCache</code></li>
<li>Increasing allocation efficiency</li>
<li>Lowering lock contention during multi-threaded access</li>
</ul>
<p>It’s like imagining you are part of a writing club. Instead of asking the supply room for one sheet of paper every time you write, you now take 8 pages at once and keep them in your drawer. This way, you save time and avoid crowding around the supply desk. That’s exactly what batch allocation achieves in memory management.</p>
<p><strong>ALSO</strong> in this memory pool design, different memory sizes are categorized by fixed alignment (8 bytes). Instead of maintaining a separate list for every possible byte size, we use an index to represent ranges (e.g., 1–8B → index 0, 9–16B → index 1, and so on). The getIndex(size) function calculates the appropriate index for any memory size, enabling the CentralCache to quickly locate the corresponding free list. This approach simplifies memory management, improves lookup efficiency, and ensures consistent alignment for reuse.</p>
<h4 id="3-PageCache"><a href="#3-PageCache" class="headerlink" title="3. PageCache"></a>3. PageCache</h4><p>PageCache is like a warehouse manager, they manage the big chunk of memory(4kb per page) that are requested from the os.<br>Its main responsibility includes:</p>
<ul>
<li>Requesting large memory chunks (via <code>mmap</code>) from the system</li>
<li>Managing and organizing memory in units of 4KB pages</li>
<li>Splitting large memory blocks into smaller spans and assigning them to <code>CentralCache</code></li>
<li>Handling span merging and memory recycling</li>
</ul>
<p>It uses:</p>
<ul>
<li><code>Span</code> structs to represent continuous page blocks</li>
<li><code>freeSpans_</code> to manage available page blocks grouped by size</li>
<li><code>spanMap_</code> to track which address belongs to which span</li>
</ul>
<h3 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h3><p>Comparing to version two, the improvement is that the ThreadCache uses batch allocation from the CentralCache.</p>
<h2 id="My-Inplementation-WIP…"><a href="#My-Inplementation-WIP…" class="headerlink" title="My Inplementation: WIP…"></a>My Inplementation: WIP…</h2><p>This part of the note explains the way I implement according to the basic principle that the instructor has given.<br>Including: </p>
<ol>
<li>Implementation of header files and main cpp files;</li>
<li>My comments;</li>
<li>Differences and similarities from the original project;</li>
<li>Test results.</li>
</ol>
<h3 id="📘-Disclaimer"><a href="#📘-Disclaimer" class="headerlink" title="📘 Disclaimer"></a>📘 Disclaimer</h3><p>This project is based on my understanding and reproduction of a memory pool design concept, originally learned from a paid course.<br>While the core allocation logic is standard in C++ memory management discussions, the implementation, comments, file structure and documentation here reflect my personal learning process and re-implementation.<br>This repository is intended for educational and portfolio purposes only, not for commercial distribution.</p>
<p>👉 <a href="">GitHub Repo Link</a></p>
<h2 id="🔚-Summary"><a href="#🔚-Summary" class="headerlink" title="🔚 Summary"></a>🔚 Summary</h2><p>What I’ve learned in this project:</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MemoryPoolProject/">MemoryPoolProject</a></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/05/20/chaloubuqe_001/" title="查漏补缺：单例模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">查漏补缺：单例模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NEW-PROJECT-Memory-Pool"><span class="toc-number">1.</span> <span class="toc-text">NEW PROJECT! Memory Pool!!</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prerequisites"><span class="toc-number">1.1.</span> <span class="toc-text">Prerequisites:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-allocator"><span class="toc-number">1.1.1.</span> <span class="toc-text">STL::allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SGI-STL-allocator"><span class="toc-number">1.1.2.</span> <span class="toc-text">SGI STL allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#first-level-allocator"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">first-level allocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#second-level-allocator"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">second-level allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Logic-Flow-of-the-second-level-allocator"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">Logic Flow of the second-level allocator:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spinlock"><span class="toc-number">1.1.3.</span> <span class="toc-text">Spinlock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#When-to-use-spinlocks"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">When to use spinlocks?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Advantages-of-spinlocks"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">Advantages of spinlocks:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disadvantages"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Disadvantages:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spinlock-vs-Mutex"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">Spinlock vs. Mutex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-framework-provided-by-instructor"><span class="toc-number">1.2.</span> <span class="toc-text">Code framework:(provided by instructor)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Version-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Version 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Optimization-lock-free-datastructure"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Optimization: lock-free datastructure</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Version-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">Version 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ThreadCache"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. ThreadCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CentralCache"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. CentralCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-PageCache"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. PageCache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Version-3"><span class="toc-number">1.2.3.</span> <span class="toc-text">Version 3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#My-Inplementation-WIP%E2%80%A6"><span class="toc-number">1.3.</span> <span class="toc-text">My Inplementation: WIP…</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%98-Disclaimer"><span class="toc-number">1.3.1.</span> <span class="toc-text">📘 Disclaimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%9A-Summary"><span class="toc-number">1.4.</span> <span class="toc-text">🔚 Summary</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Chengcen Fu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>